---

## 📄 코드 요약

```c
#include <stdio.h>
#include <ctype.h>

int main() {
    char *p = "It is 8";
    char result[100];
    int i;

    for (i = 0; p[i] != '\0'; i++) {
        if (isupper(p[i]))
            result[i] = (p[i] - 'A' + 5) % 25 + 'A';
        else if (islower(p[i]))
            result[i] = (p[i] - 'a' + 10) % 26 + 'a';
        else if (isdigit(p[i]))
            result[i] = (p[i] - '0' + 3) % 10 + '0';
        else if (!(isupper(p[i]) || islower(p[i]) || isdigit(p[i])))
            result[i] = p[i];
    }

    result[i] = '\0';
    printf("%s\n", result);

    return 0;
}
```

---

## 🔍 문자열 `"It is 8"` 분석

문자열: `"I", "t", " ", "i", "s", " ", "8"`

| 문자  | 조건  | 처리 방식                                                                  | 계산 | 결과 |
| --- | --- | ---------------------------------------------------------------------- | -- | -- |
| 'I' | 대문자 | `(I - 'A' + 5) % 25 + 'A'` = `(8 + 5) % 25 + 65` → 13 + 65 = **'N'**   |    |    |
| 't' | 소문자 | `(t - 'a' + 10) % 26 + 'a'` = `(19 + 10) % 26 + 97` = 3 + 97 = **'d'** |    |    |
| ' ' | 공백  | 조건 충족 안 함 → 그대로 **' '**                                                |    |    |
| 'i' | 소문자 | `(8 + 10) % 26 + 97 = 18 + 97` = **'s'**                               |    |    |
| 's' | 소문자 | `(18 + 10) % 26 + 97 = 28 % 26 + 97 = 2 + 97` = **'c'**                |    |    |
| ' ' | 공백  | 그대로 **' '**                                                            |    |    |
| '8' | 숫자  | `(8 + 3) % 10 + 48 = 11 % 10 + 48 = 1 + 48` = **'1'**                  |    |    |

---

## ✅ 최종 문자열

```text
Nd sc 1
```

---

## ✅ 정답

```
Nd sc 1
```

---

📘 **보충 설명**

* `% 25`는 대문자 알파벳 수보다 1 작음 → 일부 대문자 변환 충돌 주의 필요
* `islower`, `isupper`, `isdigit`을 통한 조건 분기
* 단순한 시저 암호(Caesar Cipher) 방식으로 변형

---