---

## 🧮 문제 11 - C언어 2차원 포인터와 인덱싱 연산

> 📌 **문제 설명**
> 다음 C 언어 코드를 실행했을 때 출력되는 결과값을 작성하시오.

---

### 📄 문제 코드

```c
#include <stdio.h>
#include <stdlib.h>

void set(int** arr, int* data, int rows, int cols) {
    for (int i = 0; i < rows * cols; ++i) {
        arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];
    }
}

int main() {
    int rows = 3, cols = 3, sum = 0;
    int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}; 
    int** arr;
    arr = (int**) malloc(sizeof(int*) * rows);
    for (int i = 0; i < cols; i++) {
        arr[i] = (int*) malloc(sizeof(int) * cols);
    }

    set(arr, data, rows, cols);

    for (int i = 0; i < rows * cols; i++) {
        sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);
    }

    for(int i = 0; i < rows; i++) {
        free(arr[i]);
    }
    free(arr);

    printf("%d", sum);
}
```

---

### 🔍 문제 분석

#### 📌 배열 저장 과정 분석 (`set` 함수)

* `data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9}`
* `set()` 함수는 다음 식으로 인덱싱:

  ```c
  arr[((i+1)/rows) % rows][(i+1)%cols] = data[i];
  ```

| i | (i+1)/3 | %3 → 행 인덱스 | (i+1)%3 → 열 인덱스 | data\[i] | arr\[row]\[col]       |
| - | ------- | ---------- | --------------- | -------- | --------------------- |
| 0 | 1       | 1          | 1               | 5        | arr\[1]\[1] = 5       |
| 1 | 0       | 0          | 2               | 2        | arr\[0]\[2] = 2       |
| 2 | 1       | 1          | 0               | 7        | arr\[1]\[0] = 7       |
| 3 | 1       | 1          | 1               | 4        | arr\[1]\[1] = 4 (덮어씀) |
| 4 | 1       | 1          | 2               | 1        | arr\[1]\[2] = 1       |
| 5 | 2       | 2          | 0               | 8        | arr\[2]\[0] = 8       |
| 6 | 2       | 2          | 1               | 3        | arr\[2]\[1] = 3       |
| 7 | 2       | 2          | 2               | 6        | arr\[2]\[2] = 6       |
| 8 | 3       | 0          | 0               | 9        | arr\[0]\[0] = 9       |

💡 **최종 `arr` 내용 (3x3):**

```
arr[0] = { 9, ?, 2 }
arr[1] = { 7, 4, 1 }
arr[2] = { 8, 3, 6 }
```

(`arr[0][1]`은 저장되지 않아 쓰레기값일 수 있지만 이후 사용되지 않음)

---

#### 📌 합계 계산 부분 (`sum`)

```c
for (int i = 0; i < 9; i++) {
    sum += arr[i / 3][i % 3] * (i % 2 == 0 ? 1 : -1);
}
```

* 순회 순서: `arr[0][0]`, `arr[0][1]`, ..., `arr[2][2]`
* 계산: (홀수 번째는 음수)

| i | i/3 | i%3 | 값         | 부호 | 항      |
| - | --- | --- | --------- | -- | ------ |
| 0 | 0   | 0   | 9         | +1 | +9     |
| 1 | 0   | 1   | 쓰레기값 → 무시 | -1 | 💥(주의) |
| 2 | 0   | 2   | 2         | +1 | +2     |
| 3 | 1   | 0   | 7         | -1 | -7     |
| 4 | 1   | 1   | 4         | +1 | +4     |
| 5 | 1   | 2   | 1         | -1 | -1     |
| 6 | 2   | 0   | 8         | +1 | +8     |
| 7 | 2   | 1   | 3         | -1 | -3     |
| 8 | 2   | 2   | 6         | +1 | +6     |

* 정리: `9 + 2 - 7 + 4 - 1 + 8 - 3 + 6 = **18**`
  (※ arr\[0]\[1]은 계산에서 제외하거나 무시되어야 정상 동작)

---

### ✅ 출력 결과

```
18
```

---

### 💡 해설 요약

| 항목       | 설명                                      |
| -------- | --------------------------------------- |
| 2차원 포인터  | `int** arr` + `malloc`로 행 단위로 메모리 동적 할당 |
| set() 함수 | 주어진 데이터 배열을 비정형 인덱싱 방식으로 2차원 배열에 저장     |
| 배열 덮어쓰기  | `arr[1][1]`은 두 번 저장되어 마지막 값만 유지         |
| 계산 방식    | `짝수 index → +`, `홀수 index → -` 로 곱하여 누적 |

---

### 📘 관련 개념

| 개념     | 설명                                     |
| ------ | -------------------------------------- |
| 동적 할당  | `malloc`을 통해 2차원 배열처럼 사용하는 구조 생성       |
| 인덱스 계산 | `i / rows`, `i % cols`를 활용한 평면화/복원     |
| 포인터 배열 | `int**`는 "포인터의 배열"로 메모리를 계층적으로 다룰 수 있음 |

---